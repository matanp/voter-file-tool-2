# 3.1 Jurisdiction Assignment — Code Review Findings & Fixes

**Ticket:** [3.1-jurisdiction-assignment-ui.md](./3.1-jurisdiction-assignment-ui.md)  
**Review Date:** 2025-02-20  
**Branch:** feat/srs-implementation-tier3-2

---

## Summary

Each finding from the code review was verified against the current codebase. Fixes were applied only where necessary. Details below.

---

## Finding 1: UserJurisdiction Unique Constraint and NULL legDistrict

**Location:** `apps/frontend/prisma/schema.prisma` (lines 305–321)

**Finding:** The `@@unique([userId, cityTown, legDistrict, termId])` constraint does not prevent duplicate "all districts" rows because in PostgreSQL, NULL values in unique constraints are considered distinct. Multiple rows with `legDistrict = NULL` for the same `(userId, cityTown, termId)` could be inserted.

**Verification:** Confirmed. The schema uses `legDistrict Int?` with `@@unique([userId, cityTown, legDistrict, termId])`. PostgreSQL treats NULL ≠ NULL in unique constraints, so duplicates are allowed at the DB level.

**Fix Applied:** Added a new migration (`20260221120000_user_jurisdiction_partial_unique_legdistrict_null`) that creates a partial unique index:

```sql
CREATE UNIQUE INDEX "UserJurisdiction_userId_cityTown_termId_legDistrict_null_key"
ON "UserJurisdiction"("userId", "cityTown", "termId")
WHERE "legDistrict" IS NULL;
```

This enforces uniqueness when `legDistrict` IS NULL, complementing the existing composite unique index for non-NULL values. The Prisma schema `@@unique` is unchanged; the partial index is additive.

**Note:** The POST handler in `route.ts` already uses `findFirst` for the null case (app-level duplicate prevention). The partial index provides defense-in-depth at the database layer.

**Schema drift:** Prisma does not support partial indexes (indexes with a `WHERE` clause). This index exists only in the migration and database, not in `schema.prisma`. The schema is therefore not the full source of truth for this index. To resolve if desired: (A) drop the migration/index and rely on app-level checks; or (B) use a sentinel value (e.g. `legDistrict Int` with default `-1` for "all districts") so the standard `@@unique` enforces uniqueness and the schema remains the single source of truth.

---

## Finding 2: CommitteeSelector — userJurisdictions undefined During Loading

**Location:** `apps/frontend/src/app/committees/CommitteeSelector.tsx` (lines 481–520)

**Finding:** The runtime error occurs because `userJurisdictions` can be `undefined` during loading (from `useApiQuery`), but checks use strict `!== null`. Accessing `.length` on `undefined` throws.

**Verification:** Confirmed. `userJurisdictions = userJurisdictionsQuery.data` is `undefined` while the query is loading. The checks `userJurisdictions !== null` evaluate to true when `userJurisdictions` is `undefined`, so the code could enter the block and then access `userJurisdictions.length`, causing a TypeError.

**Fix Applied:** Replaced strict null checks with loose equality so both `null` and `undefined` are handled:

- `userJurisdictions !== null` → `userJurisdictions != null` in both conditional blocks
- `!= null` is equivalent to `!== null && !== undefined`, so `undefined` no longer reaches `.length`

---

## Finding 3: page.tsx — jurisdictions Undefined Check

**Location:** `apps/frontend/src/app/committees/page.tsx` (lines 40–46)

**Finding:** The check `jurisdictions !== null && jurisdictions.length > 0` could throw if `jurisdictions` is `undefined`.

**Verification:** `getUserJurisdictions()` returns `Promise<UserJurisdiction[] | null>`; it does not return `undefined`. In normal execution, `jurisdictions` is always `UserJurisdiction[] | null`. The finding is defensive; the code path would only see `undefined` in an exceptional case.

**Fix Applied:** Guard updated to `Array.isArray(jurisdictions) && jurisdictions.length > 0` for robustness. This safely handles both `null` and `undefined` and documents the expectation that `jurisdictions` is an array when used.

---

## Finding 4: assignJurisdictionSchema — legDistrict Positive Constraint

**Location:** `apps/frontend/src/lib/validations/committee.ts` (lines 536–543)

**Finding:** `assignJurisdictionSchema` allows zero or negative `legDistrict` because it uses `z.coerce.number().int().optional()` without a positive constraint.

**Verification:** Confirmed. `committeeRequestDataSchema` and `removeCommitteeDataSchema` use `.refine((val) => val === undefined || val > 0, ...)` for legDistrict; `assignJurisdictionSchema` did not.

**Fix Applied:** Added the same positive-integer refinement when `legDistrict` is provided:

```ts
legDistrict: z.coerce
  .number()
  .int()
  .optional()
  .refine((val) => val === undefined || val > 0, {
    message: "Legislative District must be a positive integer when provided",
  }),
```

---

## Finding 5: 3.1-jurisdiction-assignment-ui.md — "Implemented" Label Inconsistency

**Location:** `docs/SRS/tickets/3.1-jurisdiction-assignment-ui.md` (lines 101–104)

**Finding:** The doc labels the item as "Implemented:" while related acceptance criteria remain unchecked and the ticket status is "Open", causing inconsistency.

**Verification:** The "Implemented:" text appears under the "Invite/User Management Flow" section and refers to "No changes to Invite model" — a design decision, not the empty-state acceptance criteria. The empty-state criteria (lines 91–94, 96–98) were already implemented per the code review but were not marked complete in the ticket.

**Fix Applied:** Changed "Implemented:" to "Decided:" to clarify that this is a design decision, not a completed feature. The sentence now reads: "**Decided:** No changes to Invite model or invite API. Admins assign jurisdictions in Admin > Users after the user exists."

---

## Finding 6: Migration — Unique Index and NULL legDistrict

**Location:** `apps/frontend/prisma/migrations/20260221043928_add_user_jurisdiction/migration.sql` (lines 23–24)

**Finding:** The unique index `UserJurisdiction_userId_cityTown_legDistrict_termId_key` allows duplicate rows when `legDistrict` is NULL.

**Verification:** Confirmed. The migration creates a standard unique index that does not treat NULLs as equal in PostgreSQL.

**Fix Applied:** Per project rules, existing migrations are immutable. A **new** migration was added (see Finding 1) to create a partial unique index that enforces uniqueness when `legDistrict IS NULL`. The original migration file was not edited.

---

## Finding 7: UsersClient — PrivilegeLevel Enum for isLeader Check

**Location:** `apps/frontend/src/app/admin/users/UsersClient.tsx` (line 202)

**Finding:** The code uses `user.privilegeLevel === "Leader"` instead of the `PrivilegeLevel` enum.

**Verification:** Confirmed. Line 202 has `const isLeader = user.privilegeLevel === "Leader"`.

**Fix Applied:** Updated to `user.privilegeLevel === PrivilegeLevel.Leader` and added `PrivilegeLevel` import from `@prisma/client`.

---

## Finding 8: UsersClient — roleLabel String Literals

**Location:** `apps/frontend/src/app/admin/users/UsersClient.tsx` (lines 49–60)

**Finding:** `roleLabel` uses string literals instead of the `PrivilegeLevel` enum. The parameter should be typed as `PrivilegeLevel` and cases should use the enum.

**Verification:** Confirmed. The function uses `case "Developer"`, `case "Admin"`, `case "Leader"` with a `string` parameter type.

**Fix Applied:** Updated `roleLabel` to:
- Accept `PrivilegeLevel` as the parameter type
- Use `PrivilegeLevel.Developer`, `PrivilegeLevel.Admin`, `PrivilegeLevel.Leader` in switch cases
- Added a brief JSDoc comment describing that it maps a `PrivilegeLevel` to a human-readable label
- Ensured `PrivilegeLevel` is imported from `@prisma/client`

---

## Finding 9: jurisdictions [id] Route — Error Response Consistency

**Location:** `apps/frontend/src/app/api/admin/jurisdictions/[id]/route.ts` (lines 23–25)

**Finding:** The early return for a missing `params` object uses `NextResponse.json({ error: "Not found" }, { status: 404 })` without `success: false`, unlike other error responses in the route.

**Verification:** Confirmed. The jurisdiction-not-found response (lines 32–35) returns `{ success: false, error: "..." }`, but the params-missing response (line 24) returns only `{ error: "Not found" }`.

**Fix Applied:** Updated the params-missing return to include `success: false`:

```ts
return NextResponse.json({ success: false, error: "Not found" }, { status: 404 });
```

---

## Summary of Changes

| Finding | File(s) | Action |
|---------|---------|--------|
| 1 | `prisma/schema.prisma`, new migration | Add partial unique index for `legDistrict IS NULL` |
| 2 | `CommitteeSelector.tsx` | Change `!== null` to `!= null` for `userJurisdictions` guards |
| 3 | `page.tsx` | Use `Array.isArray(jurisdictions)` for guard |
| 4 | `committee.ts` | Add `.refine()` for positive `legDistrict` in `assignJurisdictionSchema` |
| 5 | `3.1-jurisdiction-assignment-ui.md` | Change "Implemented:" to "Decided:" |
| 6 | New migration | Same as Finding 1 (immutable migration rule) |
| 7 | `UsersClient.tsx` | Use `PrivilegeLevel.Leader` for isLeader |
| 8 | `UsersClient.tsx` | Use `PrivilegeLevel` enum in `roleLabel` |
| 9 | `jurisdictions/[id]/route.ts` | Add `success: false` to params-missing error response |
