# 1.R.4 Bulk Committee Import Incompatible with Phase 1 Schema (P1)

**Status:** Resolved
**Priority:** P1 — High
**Effort:** 2–3 days
**Depends on:** [1.2 CommitteeMembership Model](1.2-committee-membership-model.md), [1.4 Seat Model](1.4-seat-model.md)

## Summary

`bulkLoadCommittees` (via `bulkLoadUtils.ts`) still uses the deprecated membership model. It performs `committeeList.deleteMany({})`, which can cascade or conflict with Phase 1 FKs (Seat, CommitteeMembership reference CommitteeList). It also writes `VoterRecord.committeeId` instead of creating/updating `CommitteeMembership` records. This is a high-risk failure path; even if it runs, it bypasses the new authoritative membership model and can corrupt term history.

## Root Cause

- **File:** `apps/frontend/src/app/api/admin/bulkLoadCommittees/bulkLoadUtils.ts`
- Line 137: `prisma.committeeList.deleteMany({})` — dangerous with restrict FKs
- Line 157: `prisma.voterRecord.updateMany({ data: { committeeId: committee.id } })` — deprecated field

## Acceptance Criteria

- [x] Stop writing `VoterRecord.committeeId`; do not use it for membership.
- [x] For each committee in the import:
  - Upsert `CommitteeList` (or equivalent) without full delete-first.
  - Create/update `CommitteeMembership` records with `status=ACTIVE` for each member, linked to the correct `committeeListId` and `termId`.
  - Use `ensureSeatsExist` and `assignNextAvailableSeat` (or bulk equivalent) for seat assignment.
- [x] Remove or replace `committeeList.deleteMany({})` with a safe strategy (e.g. per-committee upsert, or explicit term-scoped replace that respects FK constraints).
- [x] Ensure Seat and CommitteeMembership FKs are satisfied; no orphaned or invalid references.
- [x] Add/update bulk import tests to assert CommitteeMembership creation and no `committeeId` writes.
- [x] Document migration path for existing bulk-import data if `committeeId` was populated.

## Implementation Notes

- **File:** `apps/frontend/src/app/api/admin/bulkLoadCommittees/bulkLoadUtils.ts`
- Phase 1 source of truth: `CommitteeMembership` with `Seat` for assignment.
- Consider transaction scope for bulk operations to avoid partial state.
- Reference `add` route and `handleRequest` for patterns (ensureSeatsExist, assignNextAvailableSeat).

## Legacy `committeeId` Migration Path

For environments that previously populated `VoterRecord.committeeId`, use this one-time backfill approach:

1. Snapshot affected rows:
   - `SELECT "VRCNUM", "committeeId" FROM "VoterRecord" WHERE "committeeId" IS NOT NULL;`
2. For each snapshot row, resolve committee to the active term and insert missing membership:
   - Upsert or find `CommitteeList` in the active term.
   - Insert `CommitteeMembership` only when no `(voterRecordId, committeeListId, termId)` row exists.
   - Set `status='ACTIVE'`, `membershipType='APPOINTED'`, and allocate `seatNumber` via `assignNextAvailableSeat` semantics.
3. Validate post-backfill:
   - Every non-null legacy `committeeId` row has one active `CommitteeMembership` in the active term.
   - No committee exceeds `maxSeatsPerLted`.
4. Freeze legacy field usage:
   - Keep `VoterRecord.committeeId` read-only for compatibility.
   - All new writes must go through `CommitteeMembership` + `Seat`.

## Related

- [1.2 CommitteeMembership Model](1.2-committee-membership-model.md)
- [1.4 Seat Model](1.4-seat-model.md)
- [1.R.5 Source-of-Truth Split](1.R.5-source-of-truth-split.md)
