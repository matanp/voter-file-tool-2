# 1.R.7 Capacity + Seat Assignment Non-Atomic (Race Risk) (P2)

**Status:** Open
**Priority:** P2 — Medium
**Effort:** 1–2 days
**Depends on:** [1.2 CommitteeMembership Model](1.2-committee-membership-model.md), [1.4 Seat Model](1.4-seat-model.md)

## Summary

Both `add` and `handleRequest` (accept) perform `countActiveMembers` → `ensureSeatsExist` → `assignNextAvailableSeat` → write membership, **without** a transaction or row-level locking. Concurrent requests can oversubscribe capacity (two requests both see `activeCount < maxSeats`, both pass) or double-assign the same seat.

## Affected Paths

- **add route:** `countActiveMembers` (line 97) → capacity check → `assignNextAvailableSeat` (line 105) → create/update (line 108+)
- **handleRequest route:** `countActiveMembers` (line 66) → capacity check → `ensureSeatsExist` (line 96) → `assignNextAvailableSeat` (line 97) → update (line 103+)

## Acceptance Criteria

- [ ] Wrap capacity check + seat assignment + membership write in a **single database transaction** for both `add` and `handleRequest` accept.
- [ ] Use `SELECT ... FOR UPDATE` or equivalent to lock the committee/term row (or relevant Seat rows) during the critical section to prevent concurrent oversubscription.
- [ ] Ensure `assignNextAvailableSeat` operates on consistent state within the transaction (no interleaving with another request).
- [ ] Add concurrency test: fire N concurrent add/accept requests where N would exceed capacity; assert exactly `maxSeats` succeed and the rest receive capacity error.
- [ ] Document transaction boundaries and any isolation level requirements.

## Implementation Notes

- **Files:** `apps/frontend/src/app/api/committee/add/route.ts`, `apps/frontend/src/app/api/committee/handleRequest/route.ts`
- **Pattern:** `prisma.$transaction(async (tx) => { ... })` with `tx.committeeMembership`, `tx.seat`, etc.
- **Locking:** Prisma doesn't support raw `FOR UPDATE`; consider `tx.$queryRaw` for advisory lock or use `tx.committeeList.findUnique({ where: {...} })` then `tx.committeeMembership.count` and `tx.seat.findFirst` within the same transaction — serialization may suffice if transaction is short.
- **Alternative:** Use a dedicated "seat allocation" primitive that atomically claims the next free seat.

## Related

- [1.4 Seat Model](1.4-seat-model.md)
- [2.4 Meeting Record Workflow](2.4-meeting-record-confirmation-workflow.md) — bulk confirm will have similar needs
